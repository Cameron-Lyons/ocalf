[[exercises]]
name = "intro1"
dir = "00_intro"
hint = """
Welcome to OCalf! Your first task is to fix the syntax error.
In OCaml, strings are enclosed in double quotes.
"""

[[exercises]]
name = "intro2"
dir = "00_intro"
hint = """
OCaml has two types of comments:
- (* Regular comments *)
- (** Documentation comments **)
Comments can span multiple lines.
"""

[[exercises]]
name = "variables1"
dir = "01_variables"
hint = """
In OCaml, you bind values to names using `let`:
  let x = 5
The value on the right is bound to the name on the left.
"""

[[exercises]]
name = "variables2"
dir = "01_variables"
hint = """
You can add type annotations to let bindings:
  let x : int = 5
  let name : string = "Alice"
The type comes after a colon, before the equals sign.
"""

[[exercises]]
name = "variables3"
dir = "01_variables"
hint = """
OCaml allows shadowing - you can rebind a name to a new value:
  let x = 5
  let x = x + 1  (* x is now 6 *)
This creates a new binding, it doesn't mutate the original.
"""

[[exercises]]
name = "variables4"
dir = "01_variables"
hint = """
The `let ... in` expression creates a local scope:
  let x = 5 in
  let y = x + 1 in
  x + y
The bindings are only visible within the `in` expression.
"""

[[exercises]]
name = "functions1"
dir = "02_functions"
hint = """
Functions are defined using `let`:
  let add x y = x + y
Parameters come after the function name, separated by spaces.
"""

[[exercises]]
name = "functions2"
dir = "02_functions"
hint = """
Functions can take multiple parameters:
  let greet name age = ...
Call them with: greet "Alice" 30
"""

[[exercises]]
name = "functions3"
dir = "02_functions"
hint = """
Labeled arguments use ~ prefix:
  let greet ~name ~age = ...
Call with: greet ~name:"Alice" ~age:30
Or with punning: let name = "Alice" in greet ~name ~age:30
"""

[[exercises]]
name = "functions4"
dir = "02_functions"
hint = """
Optional arguments use ? prefix and provide defaults:
  let greet ?(greeting="Hello") name = greeting ^ ", " ^ name
Call with: greet "Alice"  (* uses default *)
Or: greet ~greeting:"Hi" "Bob"
"""

[[exercises]]
name = "functions5"
dir = "02_functions"
hint = """
Partial application: apply some arguments to get a new function:
  let add x y = x + y
  let add5 = add 5  (* add5 is a function that adds 5 *)
  add5 3  (* returns 8 *)
"""

[[exercises]]
name = "if1"
dir = "03_if"
hint = """
The basic if/then/else syntax:
  if condition then value1 else value2
Both branches must have the same type!
"""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """
You can nest conditionals with `else if`:
  if x < 0 then "negative"
  else if x = 0 then "zero"
  else "positive"
"""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """
In OCaml, `if` is an expression that returns a value:
  let result = if x > 0 then x * 2 else 0
The value of the if expression is the value of the chosen branch.
"""

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
hint = """
OCaml's primitive types:
- int: 42, -5
- float: 3.14, 2.0 (note: use 2.0, not 2.)
- bool: true, false
- char: 'a', 'Z', '\\n'
"""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
hint = """
String operations:
- Concatenation: "Hello" ^ " World"
- Length: String.length "abc"
- Get char: String.get "abc" 0  (* returns 'a' *)
- Substring: String.sub "hello" 1 3  (* returns "ell" *)
"""

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
hint = """
Type conversion functions:
- int_of_float 3.14  (* returns 3 *)
- float_of_int 5  (* returns 5.0 *)
- string_of_int 42  (* returns "42" *)
- int_of_string "42"  (* returns 42 *)
- Char.code 'a'  (* returns 97 *)
- Char.chr 97  (* returns 'a' *)
"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """
The unit type () represents "no meaningful value":
- Used for side effects: print_endline "hi" returns ()
- Unit type functions: let do_nothing () = ()
- Similar to void in other languages
"""

[[exercises]]
name = "tuples1"
dir = "05_tuples"
hint = """
Tuples group multiple values:
  let pair = (1, "hello")
  let triple = (1, 2.0, true)
Tuples can contain values of different types.
"""

[[exercises]]
name = "tuples2"
dir = "05_tuples"
hint = """
Destructure tuples with pattern matching:
  let (x, y) = (1, 2)
  let (a, b, c) = triple
For pairs, you can also use fst and snd:
  fst (1, 2)  (* returns 1 *)
  snd (1, 2)  (* returns 2 *)
"""

[[exercises]]
name = "tuples3"
dir = "05_tuples"
hint = """
Functions can return tuples to return multiple values:
  let divide_with_remainder a b = (a / b, a mod b)
  let (quotient, remainder) = divide_with_remainder 10 3
"""

[[exercises]]
name = "records1"
dir = "06_records"
hint = """
Define a record type first:
  type person = { name : string; age : int }
Then create values:
  let alice = { name = "Alice"; age = 30 }
"""

[[exercises]]
name = "records2"
dir = "06_records"
hint = """
Access fields with dot notation:
  alice.name  (* "Alice" *)
Create updated copies with { ... with ... }:
  let older_alice = { alice with age = 31 }
"""

[[exercises]]
name = "records3"
dir = "06_records"
hint = """
Mutable record fields use the `mutable` keyword:
  type counter = { mutable count : int }
Update with <-:
  let c = { count = 0 }
  c.count <- c.count + 1
"""

[[exercises]]
name = "records4"
dir = "06_records"
hint = """
Records can be nested:
  type address = { street : string; city : string }
  type person = { name : string; address : address }
Access nested fields: person.address.city
"""

[[exercises]]
name = "variants1"
dir = "07_variants"
hint = """
Simple variants (enums) are defined with |:
  type color = Red | Green | Blue
Constructors must start with uppercase.
"""

[[exercises]]
name = "variants2"
dir = "07_variants"
hint = """
Variants can carry data:
  type shape =
    | Circle of float
    | Rectangle of float * float
Create values:
  let c = Circle 5.0
  let r = Rectangle (3.0, 4.0)
"""

[[exercises]]
name = "variants3"
dir = "07_variants"
hint = """
Variants can be recursive (for trees):
  type tree =
    | Leaf
    | Node of int * tree * tree
Create: Node (1, Leaf, Node (2, Leaf, Leaf))
"""

[[exercises]]
name = "variants4"
dir = "07_variants"
hint = """
Polymorphic variants use backtick prefix:
  let color = `Red
  let status = `Ok 42 | `Error "oops"
They don't need predefined type declarations.
"""

[[exercises]]
name = "pattern_matching1"
dir = "08_pattern_matching"
hint = """
Match on variants:
  match color with
  | Red -> "red"
  | Green -> "green"
  | Blue -> "blue"
"""

[[exercises]]
name = "pattern_matching2"
dir = "08_pattern_matching"
hint = """
Match on tuples:
  match pair with
  | (0, 0) -> "origin"
  | (x, 0) -> "on x-axis"
  | (0, y) -> "on y-axis"
  | (x, y) -> "elsewhere"
"""

[[exercises]]
name = "pattern_matching3"
dir = "08_pattern_matching"
hint = """
Guards add conditions with `when`:
  match x with
  | n when n < 0 -> "negative"
  | n when n = 0 -> "zero"
  | n -> "positive"
"""

[[exercises]]
name = "pattern_matching4"
dir = "08_pattern_matching"
hint = """
The `as` pattern binds a name to the whole matched value:
  match list with
  | ([] as empty) -> empty
  | (head :: tail as whole) -> whole
"""

[[exercises]]
name = "pattern_matching5"
dir = "08_pattern_matching"
hint = """
OCaml warns about non-exhaustive matches!
Use _ as a wildcard to match anything:
  match x with
  | Some y -> y
  | None -> 0
Or use _ for catch-all:
  match x with
  | 0 -> "zero"
  | _ -> "non-zero"
"""

[[exercises]]
name = "lists1"
dir = "09_lists"
hint = """
Lists are created with []:
  let numbers = [1; 2; 3]
Note: use semicolons, not commas!
The :: operator prepends: 0 :: [1; 2]  (* [0; 1; 2] *)
"""

[[exercises]]
name = "lists2"
dir = "09_lists"
hint = """
Pattern match on lists:
  match list with
  | [] -> "empty"
  | [x] -> "one element"
  | [x; y] -> "two elements"
  | head :: tail -> "at least one"
"""

[[exercises]]
name = "lists3"
dir = "09_lists"
hint = """
List.map transforms each element:
  List.map (fun x -> x * 2) [1; 2; 3]  (* [2; 4; 6] *)
List.filter keeps matching elements:
  List.filter (fun x -> x > 0) [-1; 2; -3; 4]  (* [2; 4] *)
"""

[[exercises]]
name = "lists4"
dir = "09_lists"
hint = """
List.fold_left accumulates from left:
  List.fold_left (+) 0 [1; 2; 3]  (* 6 *)
  List.fold_left (fun acc x -> x :: acc) [] [1; 2; 3]  (* [3; 2; 1] *)
List.fold_right goes from right (less efficient).
"""

[[exercises]]
name = "lists5"
dir = "09_lists"
hint = """
Useful list patterns:
  List.concat [[1; 2]; [3; 4]]  (* [1; 2; 3; 4] *)
  List.flatten  (* same as concat *)
  List.rev [1; 2; 3]  (* [3; 2; 1] *)
  list1 @ list2  (* append lists *)
"""

[[exercises]]
name = "options1"
dir = "10_options"
hint = """
Option type represents optional values:
  type 'a option = None | Some of 'a
Use Some to wrap a value:
  let x = Some 42
  let nothing = None
"""

[[exercises]]
name = "options2"
dir = "10_options"
hint = """
Pattern match on options:
  match opt with
  | Some x -> "got " ^ string_of_int x
  | None -> "nothing"
"""

[[exercises]]
name = "options3"
dir = "10_options"
hint = """
Option module functions:
  Option.map (fun x -> x + 1) (Some 5)  (* Some 6 *)
  Option.map (fun x -> x + 1) None  (* None *)
  Option.bind (Some 5) (fun x -> Some (x + 1))  (* Some 6 *)
"""

[[exercises]]
name = "options4"
dir = "10_options"
hint = """
Chain optional operations with Option.bind:
  let get_name id = ...  (* returns string option *)
  let get_age name = ...  (* returns int option *)
  Option.bind (get_name id) get_age  (* returns int option *)
Or use let* with Option binding operators.
"""

[[exercises]]
name = "results1"
dir = "11_results"
hint = """
Result type for error handling:
  type ('a, 'b) result = Ok of 'a | Error of 'b
Use Ok for success:
  Ok 42
Use Error for failure:
  Error "something went wrong"
"""

[[exercises]]
name = "results2"
dir = "11_results"
hint = """
Pattern match on results:
  match result with
  | Ok value -> "success: " ^ string_of_int value
  | Error msg -> "error: " ^ msg
"""

[[exercises]]
name = "results3"
dir = "11_results"
hint = """
Result module functions:
  Result.map (fun x -> x + 1) (Ok 5)  (* Ok 6 *)
  Result.map (fun x -> x + 1) (Error "e")  (* Error "e" *)
  Result.bind (Ok 5) (fun x -> Ok (x + 1))
"""

[[exercises]]
name = "results4"
dir = "11_results"
hint = """
Convert between Option and Result:
  Option.to_result ~none:"missing" (Some 5)  (* Ok 5 *)
  Option.to_result ~none:"missing" None  (* Error "missing" *)
  Result.to_option (Ok 5)  (* Some 5 *)
  Result.to_option (Error "e")  (* None *)
"""

[[exercises]]
name = "modules1"
dir = "12_modules"
hint = """
Define a module with `module`:
  module MyModule = struct
    let x = 5
    let add a b = a + b
  end
Access with dot notation: MyModule.add 1 2
"""

[[exercises]]
name = "modules2"
dir = "12_modules"
hint = """
Module signatures define the interface:
  module type S = sig
    val x : int
    val add : int -> int -> int
  end
Apply to a module:
  module M : S = struct ... end
"""

[[exercises]]
name = "modules3"
dir = "12_modules"
hint = """
Abstract types hide implementation:
  module type Stack = sig
    type 'a t  (* abstract - users can't see implementation *)
    val empty : 'a t
    val push : 'a -> 'a t -> 'a t
  end
"""

[[exercises]]
name = "modules4"
dir = "12_modules"
hint = """
`open` brings module contents into scope:
  open List
  map (fun x -> x + 1) [1; 2; 3]  (* instead of List.map *)
`include` copies contents into current module:
  include OtherModule
"""

[[exercises]]
name = "modules5"
dir = "12_modules"
hint = """
Modules can be nested:
  module Outer = struct
    module Inner = struct
      let x = 5
    end
  end
Access: Outer.Inner.x
"""

[[exercises]]
name = "functors1"
dir = "13_functors"
hint = """
Functors are functions from modules to modules:
  module F (M : sig val x : int end) = struct
    let y = M.x + 1
  end
"""

[[exercises]]
name = "functors2"
dir = "13_functors"
hint = """
Apply a functor to create a module:
  module M = struct let x = 5 end
  module Result = F(M)  (* Result.y = 6 *)
"""

[[exercises]]
name = "functors3"
dir = "13_functors"
hint = """
Set and Map require comparison functions via functors:
  module IntSet = Set.Make(Int)
  let s = IntSet.of_list [1; 2; 3]
  module StringMap = Map.Make(String)
"""

[[exercises]]
name = "functors4"
dir = "13_functors"
hint = """
First-class modules can be passed as values:
  let m = (module M : S)  (* pack module as value *)
  let module M = (val m : S) in ...  (* unpack *)
"""

[[exercises]]
name = "higher_order1"
dir = "14_higher_order"
hint = """
Functions can take other functions as arguments:
  let apply_twice f x = f (f x)
  apply_twice (fun x -> x + 1) 5  (* 7 *)
"""

[[exercises]]
name = "higher_order2"
dir = "14_higher_order"
hint = """
Functions can return other functions:
  let make_adder n = fun x -> x + n
  let add5 = make_adder 5
  add5 10  (* 15 *)
"""

[[exercises]]
name = "higher_order3"
dir = "14_higher_order"
hint = """
Composition operators:
- |> (pipe): x |> f is same as f x
  5 |> add 1 |> mul 2  (* (5 + 1) * 2 = 12 *)
- @@ (application): f @@ g @@ x is same as f (g x)
  print_endline @@ string_of_int @@ 5 + 3
"""

[[exercises]]
name = "higher_order4"
dir = "14_higher_order"
hint = """
Anonymous functions with `fun`:
  fun x -> x + 1
  fun x y -> x + y
  List.map (fun s -> String.length s) ["a"; "bb"; "ccc"]
"""

[[exercises]]
name = "higher_order5"
dir = "14_higher_order"
hint = """
Currying: multi-argument functions are really chained single-argument functions.
  let add x y = x + y
Is equivalent to:
  let add = fun x -> fun y -> x + y
So `add 5` returns a function waiting for y.
"""

[[exercises]]
name = "recursion1"
dir = "15_recursion"
hint = """
Use `rec` for recursive functions:
  let rec factorial n =
    if n <= 1 then 1
    else n * factorial (n - 1)
"""

[[exercises]]
name = "recursion2"
dir = "15_recursion"
hint = """
Mutual recursion with `and`:
  let rec is_even n =
    if n = 0 then true else is_odd (n - 1)
  and is_odd n =
    if n = 0 then false else is_even (n - 1)
"""

[[exercises]]
name = "recursion3"
dir = "15_recursion"
hint = """
Tail recursion: the recursive call is the last operation.
Non-tail (stack overflow risk):
  let rec sum = function [] -> 0 | x :: xs -> x + sum xs
Tail-recursive (efficient):
  let sum lst =
    let rec aux acc = function
      | [] -> acc
      | x :: xs -> aux (acc + x) xs
    in aux 0 lst
"""

[[exercises]]
name = "recursion4"
dir = "15_recursion"
hint = """
Recursion on recursive data structures:
  let rec tree_sum = function
    | Leaf -> 0
    | Node (v, left, right) -> v + tree_sum left + tree_sum right
"""

[[exercises]]
name = "refs1"
dir = "16_refs"
hint = """
Refs are mutable cells:
  let r = ref 5  (* create ref with initial value 5 *)
  !r  (* dereference: get the value, returns 5 *)
"""

[[exercises]]
name = "refs2"
dir = "16_refs"
hint = """
Update a ref with :=
  let r = ref 5
  r := 10  (* set value to 10 *)
  !r  (* returns 10 *)
"""

[[exercises]]
name = "refs3"
dir = "16_refs"
hint = """
Use refs sparingly - prefer immutable values.
Good uses for refs:
- Caching/memoization
- Counters for unique IDs
- Implementing imperative algorithms
"""

[[exercises]]
name = "exceptions1"
dir = "17_exceptions"
hint = """
Raise built-in exceptions:
  raise Not_found
  raise (Invalid_argument "bad input")
  raise (Failure "something failed")
Or use failwith: failwith "error message"
"""

[[exercises]]
name = "exceptions2"
dir = "17_exceptions"
hint = """
Handle exceptions with try/with:
  try
    risky_operation ()
  with
  | Not_found -> "not found"
  | Failure msg -> "failed: " ^ msg
"""

[[exercises]]
name = "exceptions3"
dir = "17_exceptions"
hint = """
Define custom exceptions:
  exception My_error
  exception Error_with_data of string * int
Raise them:
  raise My_error
  raise (Error_with_data ("oops", 42))
"""

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = """
This quiz covers variables, functions, and conditionals.
Review:
- let bindings and type annotations
- Function definitions and calls
- if/then/else expressions
"""

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = """
This quiz covers data structures and pattern matching.
Review:
- Tuples, records, and variants
- Lists and list operations
- Pattern matching syntax and guards
"""

[[exercises]]
name = "quiz3"
dir = "quizzes"
hint = """
This quiz covers modules and higher-order programming.
Review:
- Module definitions and signatures
- Functors
- Higher-order functions and composition
"""

[[exercises]]
name = "arrays1"
dir = "18_arrays"
hint = """
Arrays are mutable, fixed-size collections:
  let arr = [| 1; 2; 3 |]  (* create array *)
  arr.(0)  (* access element at index 0 *)
  Array.length arr  (* get length *)
"""

[[exercises]]
name = "arrays2"
dir = "18_arrays"
hint = """
Arrays are mutable - update elements with <-:
  let arr = [| 1; 2; 3 |]
  arr.(0) <- 10  (* set first element to 10 *)
"""

[[exercises]]
name = "arrays3"
dir = "18_arrays"
hint = """
Array module functions:
  Array.map (fun x -> x * 2) arr  (* map over array *)
  Array.fold_left (+) 0 arr  (* fold array *)
  Array.make 5 0  (* create array of 5 zeros *)
  Array.init 5 (fun i -> i)  (* create [| 0; 1; 2; 3; 4 |] *)
"""

[[exercises]]
name = "imperative1"
dir = "19_imperative"
hint = """
For loops iterate over a range:
  for i = 0 to 4 do
    (* body using i *)
  done
Use `downto` for descending:
  for i = 4 downto 0 do ... done
"""

[[exercises]]
name = "imperative2"
dir = "19_imperative"
hint = """
While loops repeat until condition is false:
  while !counter < 10 do
    counter := !counter + 1
  done
The condition is checked before each iteration.
"""

[[exercises]]
name = "imperative3"
dir = "19_imperative"
hint = """
The ; operator sequences expressions:
  expr1; expr2; expr3  (* evaluates all, returns expr3 *)
Use begin...end to group sequences:
  if cond then begin
    do_something ();
    do_another ()
  end
"""

[[exercises]]
name = "let_operators1"
dir = "20_let_operators"
hint = """
Define let* for monadic binding:
  let ( let* ) = Option.bind
  let return x = Some x

Then use it:
  let* x = some_option in
  let* y = another_option in
  return (x + y)
"""

[[exercises]]
name = "let_operators2"
dir = "20_let_operators"
hint = """
let* works with any monad (Option, Result, etc.):
  let ( let* ) = Result.bind
  let return x = Ok x

Chain operations that might fail:
  let* parsed = parse s in
  let* validated = validate parsed in
  return validated
"""

[[exercises]]
name = "io1"
dir = "21_io"
hint = """
Write to a file:
  let oc = open_out "file.txt" in
  output_string oc "content";
  close_out oc

Always close channels when done!
"""

[[exercises]]
name = "io2"
dir = "21_io"
hint = """
Read a file line by line:
  let ic = open_in "file.txt" in
  let line = input_line ic in  (* may raise End_of_file *)
  close_in ic

Use a loop with exception handling to read all lines.
"""

[[exercises]]
name = "printf1"
dir = "22_printf"
hint = """
Printf.sprintf creates formatted strings:
  Printf.sprintf "Name: %s" name  (* string *)
  Printf.sprintf "Age: %d" age  (* int *)
  Printf.sprintf "Height: %f" h  (* float *)
  Printf.sprintf "%s is %d" name age  (* multiple *)
"""

[[exercises]]
name = "printf2"
dir = "22_printf"
hint = """
Printf format specifiers:
  %05d  - pad with zeros to 5 digits
  %.2f  - 2 decimal places
  %10d  - right-align in 10 chars
  %-5s  - left-align in 5 chars
  %x    - hexadecimal
  %X    - uppercase hex
"""

[[exercises]]
name = "strings1"
dir = "23_strings"
hint = """
Basic String module functions:
  String.length "abc"  (* 3 *)
  String.uppercase_ascii "hi"  (* "HI" *)
  String.lowercase_ascii "HI"  (* "hi" *)
  String.sub "hello" 1 3  (* "ell" - start at index 1, take 3 chars *)
  String.get "abc" 0  (* 'a' *)
"""

[[exercises]]
name = "strings2"
dir = "23_strings"
hint = """
Buffer is used for efficient string building:
  let buf = Buffer.create 16 in
  Buffer.add_string buf "hello";
  Buffer.add_char buf '!';
  Buffer.contents buf  (* "hello!" *)
  Buffer.clear buf  (* empties the buffer *)
"""

[[exercises]]
name = "strings3"
dir = "23_strings"
hint = """
String splitting and searching:
  String.split_on_char ',' "a,b,c"  (* ["a"; "b"; "c"] *)
  String.concat ", " ["a"; "b"]  (* "a, b" *)
  String.contains "abc" 'b'  (* true *)
  String.starts_with ~prefix:"he" "hello"  (* true *)
  String.ends_with ~suffix:"lo" "hello"  (* true *)
"""

[[exercises]]
name = "sequences1"
dir = "24_sequences"
hint = """
Create sequences:
  Seq.empty  (* empty sequence *)
  Seq.return 42  (* single-element sequence *)
  Seq.cons 1 rest  (* prepend element *)
  List.to_seq [1; 2; 3]  (* convert list to seq *)
  List.of_seq seq  (* convert seq to list *)
"""

[[exercises]]
name = "sequences2"
dir = "24_sequences"
hint = """
Transform sequences:
  Seq.map (fun x -> x * 2) seq  (* transform each element *)
  Seq.filter (fun x -> x > 0) seq  (* keep matching elements *)
  Seq.fold_left (+) 0 seq  (* accumulate *)
  Seq.take 3 seq  (* first 3 elements *)
  Seq.drop 3 seq  (* skip first 3 *)
"""

[[exercises]]
name = "sequences3"
dir = "24_sequences"
hint = """
Generate sequences:
  Seq.unfold (fun n -> if n > 3 then None else Some (n, n+1)) 1
  (* yields 1, 2, 3 then stops *)
  Seq.ints 1  (* infinite: 1, 2, 3, 4, ... *)
Use Seq.take to limit infinite sequences.
"""

[[exercises]]
name = "hashtables1"
dir = "25_hashtables"
hint = """
Hash tables are mutable key-value stores:
  let tbl = Hashtbl.create 16 in
  Hashtbl.add tbl "key" value;
  Hashtbl.find tbl "key"  (* returns value *)
  Hashtbl.length tbl  (* number of bindings *)
"""

[[exercises]]
name = "hashtables2"
dir = "25_hashtables"
hint = """
Hash table operations:
  Hashtbl.replace tbl key new_value  (* update existing key *)
  Hashtbl.mem tbl key  (* true if key exists *)
  Hashtbl.remove tbl key  (* delete a binding *)
  Hashtbl.find_opt tbl key  (* returns option instead of raising *)
"""

[[exercises]]
name = "hashtables3"
dir = "25_hashtables"
hint = """
Hash table iteration and conversion:
  Hashtbl.iter (fun k v -> ...) tbl  (* iterate over all bindings *)
  Hashtbl.to_seq tbl  (* convert to sequence of pairs *)
  Hashtbl.of_seq seq  (* create from sequence of pairs *)
"""

[[exercises]]
name = "maps1"
dir = "26_maps"
hint = """
Maps are functional (immutable) sorted dictionaries:
  module StringMap = Map.Make(String)
  StringMap.empty  (* empty map *)
  StringMap.add "key" value map  (* returns new map with binding *)
  StringMap.find "key" map  (* find value *)
  StringMap.mem "key" map  (* check membership *)
  StringMap.cardinal map  (* number of bindings *)
"""

[[exercises]]
name = "maps2"
dir = "26_maps"
hint = """
Map transformation:
  IntMap.map f m  (* apply f to all values *)
  IntMap.filter pred m  (* keep bindings where pred key value is true *)
  IntMap.remove key m  (* return map without key *)
  IntMap.find_opt key m  (* returns option *)
"""

[[exercises]]
name = "maps3"
dir = "26_maps"
hint = """
Map folding and conversion:
  StringMap.fold (fun key value acc -> ...) map init
  StringMap.bindings map  (* list of (key, value) pairs *)
  StringMap.union (fun key v1 v2 -> Some ...) m1 m2  (* merge maps *)
Note: fold iterates in key order (ascending).
"""

[[exercises]]
name = "poly_variants1"
dir = "27_polymorphic_variants"
hint = """
Polymorphic variants use backtick prefix:
  `Red, `Green, `Blue
They don't need type declarations:
  let f = function
    | `Red -> "red"
    | `Green -> "green"
    | `Blue -> "blue"
"""

[[exercises]]
name = "poly_variants2"
dir = "27_polymorphic_variants"
hint = """
Polymorphic variant types can be composed:
  type primary = [ `Red | `Green | `Blue ]
  type extended = [ primary | `Yellow | `Cyan ]
Use #type_name in patterns to match a subtype:
  match color with
  | #primary as c -> primary_handler c
  | `Yellow -> ...
"""

[[exercises]]
name = "poly_variants3"
dir = "27_polymorphic_variants"
hint = """
Polymorphic variants can carry data:
  `Circle 5.0
  `Rect (3.0, 4.0)
  `Point
Match them just like regular variants:
  match shape with
  | `Circle r -> ...
  | `Rect (w, h) -> ...
"""

[[exercises]]
name = "gadt1"
dir = "28_gadt"
hint = """
GADTs (Generalized Algebraic Data Types) encode type info in constructors:
  type _ expr =
    | Int : int -> int expr
    | Bool : bool -> bool expr
    | Add : int expr * int expr -> int expr
The return type varies per constructor.
Use `let rec eval : type a. a expr -> a = function` for polymorphic recursion.
"""

[[exercises]]
name = "gadt2"
dir = "28_gadt"
hint = """
GADTs can encode type-safe heterogeneous structures:
  type _ hlist =
    | HNil : unit hlist
    | HCons : 'a * 'b hlist -> ('a * 'b) hlist
The type tracks the structure of the list.
For sprintf, use an accumulator string with a recursive helper:
  let rec go : type a. string -> a fmt -> a = fun acc -> function
    | Lit s -> acc ^ s  (* base case: return the accumulated string *)
    | SInt rest -> fun n -> go (acc ^ string_of_int n) rest
Each format constructor adds a function parameter to the result type.
"""

[[exercises]]
name = "lazy1"
dir = "29_lazy"
hint = """
Lazy values defer computation until forced:
  let x = lazy (expensive_computation ()) in
  Lazy.force x  (* runs the computation *)
  Lazy.force x  (* returns cached result, doesn't recompute *)
  Lazy.is_val x  (* true if already forced *)
"""

[[exercises]]
name = "lazy2"
dir = "29_lazy"
hint = """
Lazy enables infinite data structures:
  type 'a stream = Cons of 'a * 'a stream Lazy.t
  let rec nats_from n = Cons (n, lazy (nats_from (n + 1)))
Force the tail with Lazy.force to traverse.
"""

[[exercises]]
name = "quiz4"
dir = "quizzes"
hint = """
This quiz covers strings, data structures, and advanced types.
Review:
- String splitting, joining, and Buffer
- Seq.unfold for generating sequences
- Map.Make for functional maps
- Polymorphic variants with data
- Hashtbl for memoization
"""

[[exercises]]
name = "sets1"
dir = "30_sets"
hint = """
Sets are functional (immutable) collections of unique elements:
  module IntSet = Set.Make(Int)
  IntSet.empty  (* empty set *)
  IntSet.add 5 set  (* returns new set with 5 added *)
  IntSet.mem 5 set  (* true if 5 is in the set *)
  IntSet.cardinal set  (* number of elements *)
  IntSet.elements set  (* sorted list of elements *)
"""

[[exercises]]
name = "sets2"
dir = "30_sets"
hint = """
Set operations:
  IntSet.union a b  (* elements in a or b *)
  IntSet.inter a b  (* elements in both a and b *)
  IntSet.diff a b  (* elements in a but not b *)
  IntSet.subset a b  (* true if a is a subset of b *)
  IntSet.disjoint a b  (* true if a and b share no elements *)
"""

[[exercises]]
name = "sets3"
dir = "30_sets"
hint = """
Transform and query sets:
  StringSet.map f s  (* apply f to each element *)
  StringSet.filter pred s  (* keep elements matching pred *)
  StringSet.fold (fun elt acc -> ...) s init  (* fold over elements *)
  StringSet.exists pred s  (* true if any element matches *)
  StringSet.for_all pred s  (* true if all elements match *)
"""

[[exercises]]
name = "objects1"
dir = "31_objects"
hint = """
Immediate objects are created inline:
  let obj = object
    val x = 5  (* instance variable *)
    method get_x = x  (* method *)
    method double = x * 2
  end
Call methods with #: obj#get_x
"""

[[exercises]]
name = "objects2"
dir = "31_objects"
hint = """
Classes define reusable object templates:
  class counter init = object
    val mutable count = init
    method get = count
    method incr = count <- count + 1
  end
  let c = new counter 0
Inherit with: inherit parent_class args
Override with: method! name = ...
"""

[[exercises]]
name = "objects3"
dir = "31_objects"
hint = """
Object types use structural subtyping:
  type shape = < area : float; describe : string >
Any object with matching methods satisfies the type.
Create objects as functions:
  let circle r : shape = object
    method area = Float.pi *. r *. r
    method describe = "circle"
  end
"""

[[exercises]]
name = "bytes1"
dir = "32_bytes"
hint = """
Bytes are mutable sequences of characters:
  Bytes.make 5 'x'  (* create 5 bytes all 'x' *)
  Bytes.get b 0  (* get byte at index 0 *)
  Bytes.set b 0 'H'  (* set byte at index 0 *)
  Bytes.to_string b  (* convert to immutable string *)
  Bytes.of_string s  (* create mutable copy of string *)
"""

[[exercises]]
name = "bytes2"
dir = "32_bytes"
hint = """
Bytes module operations:
  Bytes.blit src src_pos dst dst_pos len  (* copy bytes between buffers *)
  Bytes.sub_string b start len  (* extract substring *)
  Bytes.cat a b  (* concatenate two byte sequences *)
  Bytes.init n f  (* create n bytes where byte i = f i *)
  Bytes.create n  (* create n uninitialized bytes *)
"""

[[exercises]]
name = "phantom_types1"
dir = "33_phantom_types"
hint = """
Phantom types add type-level tags without runtime cost:
  type meters
  type seconds
  type _ quantity = Qty : float -> _ quantity
  let meters v : meters quantity = Qty v
  let seconds v : seconds quantity = Qty v
The type parameter prevents mixing different units.
"""

[[exercises]]
name = "phantom_types2"
dir = "33_phantom_types"
hint = """
Phantom types can encode state machines:
  type locked
  type unlocked
  type _ door = Door : string -> _ door
  let lock : unlocked door -> locked door = ...
  let open_door : unlocked door -> string = ...
Only unlocked doors can be opened - enforced at compile time!
"""

[[exercises]]
name = "mutual_recursion1"
dir = "34_mutual_recursion"
hint = """
Mutually recursive functions use `and`:
  let rec is_even n =
    if n = 0 then true else is_odd (n - 1)
  and is_odd n =
    if n = 0 then false else is_even (n - 1)
Both functions can call each other.
"""

[[exercises]]
name = "mutual_recursion2"
dir = "34_mutual_recursion"
hint = """
Build an expression evaluator with recursive types:
  type expr = Num of int | Add of expr * expr | ...
  type env = (string * int) list
  let rec eval env = function
    | Num n -> n
    | Add (a, b) -> eval env a + eval env b
    | Var name -> List.assoc name env
    | Let (name, value, body) -> eval ((name, eval env value) :: env) body
"""

[[exercises]]
name = "error_handling1"
dir = "35_error_handling"
hint = """
Convert between error strategies:
  Option -> Result: match opt with Some x -> Ok x | None -> Error msg
  Result -> Option: match res with Ok x -> Some x | Error _ -> None
  Safe parsing: int_of_string_opt returns an option
Use pattern matching on each type to convert.
"""

[[exercises]]
name = "error_handling2"
dir = "35_error_handling"
hint = """
Chain error-prone operations with let*:
  let ( let* ) = Result.bind
  let validate s =
    let* n = parse_int s in
    let* n = check_positive n in
    Ok n
Each let* short-circuits on Error.
For lists: fold with let* to accumulate results.
"""

[[exercises]]
name = "quiz5"
dir = "quizzes"
hint = """
This quiz covers sets, objects, bytes, and error handling.
Review:
- Set.Make and set operations (union, inter, diff)
- Classes, inheritance, and structural object types
- Bytes for mutable string manipulation
- Result chaining with let*
"""

[[exercises]]
name = "closures1"
dir = "36_closures"
hint = """
Closures capture their environment:
  let make_adder n = fun x -> n + x
  let add5 = make_adder 5  (* n=5 is captured *)
  add5 3  (* returns 8 *)
Closures can capture mutable state too:
  let make_counter () =
    let n = ref 0 in
    fun () -> incr n; !n
"""

[[exercises]]
name = "closures2"
dir = "36_closures"
hint = """
Closures as iterators:
- Return a function that maintains internal state
- Each call advances the state and returns the next value
- Return None when exhausted (or keep going for infinite iterators)
Use `ref` for mutable state inside the closure.
"""

[[exercises]]
name = "closures3"
dir = "36_closures"
hint = """
Memoization caches function results:
  let memoize f =
    let cache = Hashtbl.create 16 in
    fun x -> match Hashtbl.find_opt cache x with
      | Some v -> v
      | None -> let v = f x in Hashtbl.add cache x v; v
For recursive memoization, use an open-recursive style:
  let memo_rec f = ... fun x -> f memoized x
"""

[[exercises]]
name = "applicatives1"
dir = "37_applicatives"
hint = """
let+ maps a function over a wrapped value:
  let ( let+ ) o f = Option.map f o
  let+ x = Some 5 in x * 2  (* Some 10 *)
It's like let* but the body returns an unwrapped value.
"""

[[exercises]]
name = "applicatives2"
dir = "37_applicatives"
hint = """
and+ combines multiple wrapped values:
  let ( and+ ) a b = match (a, b) with
    | (Some va, Some vb) -> Some (va, vb)
    | _ -> None
Use with let+:
  let+ x = Some 1 and+ y = Some 2 in x + y  (* Some 3 *)
"""

[[exercises]]
name = "queues1"
dir = "38_queues_stacks"
hint = """
Queue is a FIFO (first-in, first-out) data structure:
  let q = Queue.create () in
  Queue.push 1 q;  (* add to back *)
  Queue.pop q  (* remove from front: 1 *)
  Queue.peek q  (* look at front without removing *)
  Queue.length q  (* number of elements *)
  Queue.iter f q  (* iterate over elements *)
"""

[[exercises]]
name = "stacks1"
dir = "38_queues_stacks"
hint = """
Stack is a LIFO (last-in, first-out) data structure:
  let s = Stack.create () in
  Stack.push 1 s;  (* add to top *)
  Stack.pop s  (* remove from top: 1 *)
  Stack.top s  (* look at top without removing *)
  Stack.length s  (* number of elements *)
  Stack.iter f s  (* iterate from top to bottom *)
"""

[[exercises]]
name = "format1"
dir = "39_format"
hint = """
Format.asprintf formats strings (like Printf.sprintf but more powerful):
  Format.asprintf "Hello, %s!" "world"
  Format.asprintf "%d + %d = %d" 2 3 5
For lists, use %a with Format.pp_print_list:
  Format.asprintf "[%a]"
    (Format.pp_print_list ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "; ")
       Format.pp_print_int)
    [1; 2; 3]
"""

[[exercises]]
name = "format2"
dir = "39_format"
hint = """
Write custom pretty printers with type: Format.formatter -> 'a -> unit
  let pp_point fmt p =
    Format.fprintf fmt "(%.1f, %.1f)" p.x p.y
Use %a to embed custom printers:
  Format.fprintf fmt "Circle(center=%a)" pp_point center
"""

[[exercises]]
name = "type_annotations1"
dir = "40_type_annotations"
hint = """
Type aliases give names to existing types:
  type name = string
  type age = int
Parameterized types take type variables:
  type 'a pair = 'a * 'a
  type ('a, 'b) either = Left of 'a | Right of 'b
"""

[[exercises]]
name = "type_annotations2"
dir = "40_type_annotations"
hint = """
Locally abstract types with (type a):
  let show_any (type a) (show : a -> string) (x : a) = show x
First-class modules with type constraints:
  module type Showable = sig type t val show : t -> string end
  let show_value (type a) (module S : Showable with type t = a) x = S.show x
"""

[[exercises]]
name = "type_annotations3"
dir = "40_type_annotations"
hint = """
Object subtyping uses :> for coercion:
  let p : printable = (my_object :> printable)
The target type must be a supertype (fewer methods).
This lets you store different object types in the same list.
"""

[[exercises]]
name = "quiz6"
dir = "quizzes"
hint = """
This quiz covers closures, applicatives, data structures, and types.
Review:
- Closures capturing variables and mutable state
- let+ and and+ for applicative style
- Stack module for bracket matching
- Existential types with records
"""

[[exercises]]
name = "local_opens1"
dir = "41_local_opens"
hint = """
Local open with Module.( ... ):
  StringMap.(empty |> add "key" 5 |> add "key2" 10)
Local open with let open:
  let open Printf in sprintf "%d" 42
Both bring module contents into a limited scope.
"""

[[exercises]]
name = "local_opens2"
dir = "41_local_opens"
hint = """
Use local opens in expressions:
  IntSet.(union a b |> diff c)
  List.map Printf.(sprintf "%d") [1; 2; 3]
Local opens keep code concise without polluting the global namespace.
"""

[[exercises]]
name = "tail_recursion1"
dir = "42_tail_recursion"
hint = """
The accumulator pattern makes recursion tail-recursive:
  let length lst =
    let rec aux acc = function
      | [] -> acc
      | _ :: tl -> aux (acc + 1) tl
    in aux 0 lst
The recursive call is the last operation (tail position).
For map, accumulate results reversed, then List.rev at the end.
"""

[[exercises]]
name = "tail_recursion2"
dir = "42_tail_recursion"
hint = """
Tail-recursive flatten:
  let rec aux acc = function
    | [] -> List.rev acc
    | [] :: rest -> aux acc rest
    | (x :: xs) :: rest -> aux (x :: acc) (xs :: rest)
For partition: maintain two accumulators (yes, no), reverse both at the end.
"""

[[exercises]]
name = "tail_recursion3"
dir = "42_tail_recursion"
hint = """
For tree traversal without recursion, use an explicit work list:
  let rec aux acc = function
    | [] -> acc
    | Leaf :: rest -> aux acc rest
    | Node (v, l, r) :: rest -> aux (acc + v) (l :: r :: rest)
For in-order traversal, push items in right-self-left order.
"""

[[exercises]]
name = "functorial_design1"
dir = "43_functorial_design"
hint = """
Design a sorted list using a functor over Comparable:
  module SortedList (C : Comparable) = struct
    type t = C.t list
    let insert x lst = ... (* maintain sorted order using C.compare *)
  end
Use C.compare to decide where to insert: < 0 means before, = 0 means duplicate.
"""

[[exercises]]
name = "functorial_design2"
dir = "43_functorial_design"
hint = """
Functors can add behavior to existing modules:
  module WithLogging (S : KV_Store) = struct
    type 'a t = { store : 'a S.t; log : string list ref }
    let set k v t = t.log := msg :: !(t.log); S.set k v t.store
  end
This is the decorator pattern at the module level.
"""

[[exercises]]
name = "cps1"
dir = "44_cps"
hint = """
In CPS, every function takes an extra argument `k` (the continuation):
  let add_cps x y k = k (x + y)
Chain operations by nesting continuations:
  add_cps 2 3 (fun sum -> mul_cps sum 4 (fun result -> ...))
For fold_cps: f takes acc, element, and a continuation.
"""

[[exercises]]
name = "cps2"
dir = "44_cps"
hint = """
CPS enables early exit and backtracking:
  let rec find_cps pred lst ~on_found ~on_missing =
    match lst with
    | [] -> on_missing ()
    | x :: xs -> if pred x then on_found x
                 else find_cps pred xs ~on_found ~on_missing
For trees: search left, with on_missing continuing to search right.
"""

[[exercises]]
name = "extensible_variants1"
dir = "45_extensible_variants"
hint = """
Extensible variant types can be extended after definition:
  type event = ..
  type event += Click
  type event += KeyPress of char
Match with a catch-all _ case since new constructors can be added.
New constructors can be added anywhere, even in different modules.
"""

[[exercises]]
name = "extensible_variants2"
dir = "45_extensible_variants"
hint = """
Extensible variants work with GADTs:
  type _ command = ..
  type _ command += Get : string -> string option command
  type _ command += Set : string * string -> unit command
Handle commands with a record of polymorphic function:
  type handler = { handle : 'a. 'a command -> 'a option }
"""

[[exercises]]
name = "monads1"
dir = "46_monads"
hint = """
The Writer monad collects a log alongside computation:
  type 'a t = 'a * string list
  let return x = (x, [])
  let bind (x, log1) f = let (y, log2) = f x in (y, log1 @ log2)
  let tell msg = ((), [msg])
Use let* to chain operations that produce log entries.
"""

[[exercises]]
name = "monads2"
dir = "46_monads"
hint = """
The State monad threads state through computation:
  type ('s, 'a) t = 's -> 'a * 's
  let return x = fun s -> (x, s)
  let bind m f = fun s -> let (a, s') = m s in f a s'
  let get = fun s -> (s, s)
  let put s = fun _ -> ((), s)
Run with: State.run program initial_state
"""

[[exercises]]
name = "quiz7"
dir = "quizzes"
hint = """
This quiz covers tail recursion, CPS, extensible variants, and monads.
Review:
- Tail-recursive list operations with accumulators
- CPS for tree depth computation
- Extensible variant type matching
- Option monad for chained lookups
"""

[[exercises]]
name = "effect_handlers1"
dir = "47_effect_handlers"
hint = """
Declare an effect as an extension of Effect.t:
  type _ Effect.t += Read_env : string -> string option Effect.t
Perform it with:
  perform (Read_env "PORT")
Handle it with Effect.Deep:
  match thunk () with
  | value -> value
  | effect (Read_env key), k -> continue k (lookup key)
"""

[[exercises]]
name = "effect_handlers2"
dir = "47_effect_handlers"
hint = """
Model nondeterministic choice with an effect:
  type _ Effect.t += Choose : int list -> int Effect.t
Perform with:
  perform (Choose [a; b; c])
Handle by selecting one element and resuming:
  | effect (Choose xs), k -> continue k (pick xs)
This lets the same computation run under different strategies.
"""

[[exercises]]
name = "domains_atomics1"
dir = "48_domains_atomics"
hint = """
Use Atomic for safe shared mutable state across domains:
  let c = Atomic.make 0
  Atomic.incr c
Spawn with:
  let d = Domain.spawn (fun () -> ...)
Wait for completion with:
  Domain.join d
"""

[[exercises]]
name = "domains_atomics2"
dir = "48_domains_atomics"
hint = """
For lock-free max updates, use CAS in a retry loop:
  let cur = Atomic.get cell in
  if x <= cur then ()
  else if Atomic.compare_and_set cell cur x then ()
  else retry
Run updates in parallel domains and join them all.
"""

[[exercises]]
name = "recursive_modules1"
dir = "49_recursive_modules"
hint = """
Recursive modules use module rec ... and ...:
  module rec A : sig ... end = struct ... B.x ... end
  and B : sig ... end = struct ... A.y ... end
This allows mutually recursive definitions across module boundaries.
"""

[[exercises]]
name = "recursive_modules2"
dir = "49_recursive_modules"
hint = """
Recursive modules can also define mutually recursive types.
Pattern:
  module rec A : sig type t = ... B.t ... end = struct ... end
  and B : sig type t = ... A.t ... end = struct ... end
Call across modules to compute combined recursive functions.
"""

[[exercises]]
name = "oo_inheritance1"
dir = "50_oo_inheritance"
hint = """
Virtual classes define required methods:
  class virtual shape = object
    method virtual area : float
  end
Subclasses implement virtual methods and can inherit from concrete classes:
  class square s = object inherit rectangle s s end
"""

[[exercises]]
name = "oo_inheritance2"
dir = "50_oo_inheritance"
hint = """
Override methods with `method!` and call parent implementation via `super`:
  class child = object
    inherit parent as super
    method! m x = super#m (transform x)
  end
Useful for adding behavior (fees, logging, checks) while reusing base logic.
"""

[[exercises]]
name = "ffi_interop1"
dir = "51_ffi_interop"
hint = """
Interop usually requires explicit byte layouts.
For a 16-bit big-endian integer:
  high = (n lsr 8) land 0xFF
  low = n land 0xFF
Reconstruct with:
  (high lsl 8) lor low
"""

[[exercises]]
name = "ffi_interop2"
dir = "51_ffi_interop"
hint = """
C strings are null-terminated byte arrays.
To encode:
- allocate `len + 1`
- copy chars
- set trailing '\000'
To decode:
- scan until '\000'
- convert prefix bytes to an OCaml string.
"""

[[exercises]]
name = "parsing_rewriting1"
dir = "52_parsing_rewriting"
hint = """
A tiny parser pipeline has three phases:
1) tokenize (string -> token list)
2) parse (token list -> AST)
3) rewrite/optimize (AST -> AST)
Constant folding pattern:
  Add (Int x, Int y) -> Int (x + y)
"""

[[exercises]]
name = "parsing_rewriting2"
dir = "52_parsing_rewriting"
hint = """
A rewrite pass should recurse first, then apply local rules.
Useful simplifications for addition:
- `0 + e -> e`
- `e + 0 -> e`
- constant fold: `Int a + Int b -> Int (a + b)`
When no rule matches, rebuild the node with simplified children.
"""
